import numpy as np
import time
import random
import multiprocessing as mp
from tqdm import tqdm
import sys
from util_mter import *
import pickle

def save(G1,G2,G3,U,I,F,W,outfile):
    params = {'G1': G1, 'G2': G2, 'G3': G3, 'U':U, 'I':I, 'F':F, 'W':W}
    
    with open('logs/' + outfile + '.paras', 'wb') as output:
        pickle.dump(params, output)


def get_value(G,U,I,F,index):
    score = 0
    
    dim1,dim2,dim3 = G.shape
    u_idx,i_idx,a_idx = index[0],index[1],index[2]
    for i in range(dim1):
        for j in range(dim2):
            for k in range(dim3):
                score = score + G[i, j, k] * U[u_idx, i] * I[i_idx, j] * F[a_idx, k]
    return score


def train(overall_rating_matrix,neg_items, test_data,sps_tensor_useritemf, sps_tensor_userwordf, sps_tensor_itemwordf, 
          useritem_ls,U_dim, I_dim, F_dim, W_dim, U_num, I_num, F_num, W_num, lmd_BPR,ld_reg,rec_k, num_iter, 
          print_every, outfile, lr, params, random_seed=999, eps=1e-8,num_samples_bpr = 50,num_samples_mse = 50, dataset = None):
    
    U_dim_initial = (U_num, U_dim)
    I_dim_initial = (I_num, I_dim)
    F_dim_initial = (F_num + 1, F_dim)
    W_dim_initial = (W_num, W_dim)
    G1_dim_initial = (U_dim, I_dim, F_dim)
    G2_dim_initial = (U_dim, F_dim, W_dim)
    G3_dim_initial = (I_dim, F_dim, W_dim)
    
    G1 = params[4].reshape(G1_dim_initial)
    G2 = params[5].reshape(G2_dim_initial)
    G3 = params[6].reshape(G3_dim_initial)
    U = params[0].reshape(U_dim_initial)
    I = params[1].reshape(I_dim_initial)
    A = params[2].reshape(F_dim_initial)
    O = params[3].reshape(W_dim_initial)
    
    seen_mse1 = set()
    seen_mse2 = set()
    seen_mse3 = set()
    seen_bpr = set()
    
    if num_samples_mse == -1:
        num_samples_mse = min(len(sps_tensor_useritemf),len(sps_tensor_userwordf),len(sps_tensor_itemwordf))
    
    if num_samples_bpr == -1:
        num_samples_bpr = len(useritem_ls)
    
    
    np.random.seed(random_seed)
    random.seed(random_seed)
    uifs,ufws,ifws,total_mse = [],[],[],[]
    ndcgs,precisions, recalls,f1s = [],[],[],[]
    bpr_loss = []
    print("WEIGHTS\n\n")
    print("G1: ",np.linalg.norm(G1))
    print("G2: ",np.linalg.norm(G2))
    print("G3: ",np.linalg.norm(G3))
    print("U: ",np.linalg.norm(U))
    print("I: ",np.linalg.norm(I))
    print("F: ",np.linalg.norm(A))
    print("W: ",np.linalg.norm(O))
    
    done = {'mse1':0,'mse2':0,'mse3':0,'bpr':0}
    
    
    print("Initial metrics for all users:")
    test(test_data,G1, U, I, A,rec_k = rec_k, val = True)
    
    for epoch in tqdm(range(1, 1 + num_iter)):
        print("="*50)
        print("Epoch ",epoch)
        error_square = 0
        error_bpr = 0
        
        del_u = np.zeros(shape = U_dim_initial)
        del_i = np.zeros(shape = I_dim_initial)
        del_a = np.zeros(shape = F_dim_initial)
        del_o = np.zeros(shape = W_dim_initial)
        del_g1 = np.zeros(shape = G1_dim_initial)
        del_g2 = np.zeros(shape = G2_dim_initial)
        del_g3 = np.zeros(shape = G3_dim_initial)
        
        sgrad_G1 = np.zeros_like(del_g1).astype(np.float32)
        sgrad_G2 = np.zeros_like(del_g2).astype(np.float32)
        sgrad_G3 = np.zeros_like(del_g3).astype(np.float32)
        sgrad_U = np.zeros_like(del_u).astype(np.float32)
        sgrad_I = np.zeros_like(del_i).astype(np.float32)
        sgrad_A = np.zeros_like(del_a).astype(np.float32)
        sgrad_O = np.zeros_like(del_o).astype(np.float32)
        
        
        del_g1_reg = np.zeros_like(del_g1).astype(np.float32)
        del_g2_reg = np.zeros_like(del_g2).astype(np.float32)
        del_g3_reg = np.zeros_like(del_g3).astype(np.float32)
        del_u_reg = np.zeros_like(del_u).astype(np.float32)
        del_i_reg = np.zeros_like(del_i).astype(np.float32)
        del_a_reg = np.zeros_like(del_a).astype(np.float32)
        del_o_reg = np.zeros_like(del_o).astype(np.float32)
        
        
        # MSE based batch training: Need to train these one by one
        avail_mse1 = len(set(sps_tensor_useritemf.keys()) - seen_mse1)
        avail_mse2 = len(set(sps_tensor_userwordf.keys()) - seen_mse2)
        avail_mse3 = len(set(sps_tensor_itemwordf.keys()) - seen_mse3)
        avail_bpr = len(set(useritem_ls) - seen_bpr)
        mse_sample_1 = random.sample(set(sps_tensor_useritemf.keys()) - seen_mse1, min(num_samples_bpr,avail_mse1))
        mse_sample_2 = random.sample(set(sps_tensor_userwordf.keys()) - seen_mse2, min(num_samples_mse,avail_mse2))
        mse_sample_3 = random.sample(set(sps_tensor_itemwordf.keys()) - seen_mse3, min(num_samples_mse,avail_mse3))
        bpr_sample_ele = random.sample(set(useritem_ls) - seen_bpr, min(num_samples_bpr,avail_bpr))
        
        seen_mse1.update(mse_sample_1)
        seen_mse2.update(mse_sample_2)
        seen_mse3.update(mse_sample_3)
        seen_bpr.update(bpr_sample_ele)
        
        if len(set(sps_tensor_useritemf.keys()) - seen_mse1) == 0:
            done['mse1'] += 1
            print("Done training ",done['mse1'] ," full epochs of UIF data")
            seen_mse1 = set()
        
        if len(set(sps_tensor_userwordf.keys()) - seen_mse2) == 0:
            done['mse2'] += 1
            print("Done training ",done['mse2'] ," full epochs of UFW data")
            seen_mse2 = set()
        
        if len(set(sps_tensor_itemwordf.keys()) - seen_mse3) == 0:
            done['mse3'] += 1
            print("Done training ",done['mse3'] ," full epochs of IFW data")
            seen_mse3 = set()
        
        if len(set(useritem_ls) - seen_bpr) == 0:
            done['bpr'] += 1
            print("Done training ",done['bpr'] ," full epochs of BPR data")
            seen_bpr = set()
        
        
        print("Training UIF")
        uif_mse = 0
        # For the UIF portion
        for key in tqdm(mse_sample_1):
            
            pred_rating = get_value(G1, U, I, A, key)
            del_sqerror = 2 * (pred_rating - sps_tensor_useritemf[key])
            error_square += (pred_rating - sps_tensor_useritemf[key])**2
            u_idx,i_idx,a_idx = key[0],key[1],key[2]
            for i in range(U_dim):
                for j in range(I_dim):
                    for k in range(F_dim):
                        del_g1[i, j, k] += del_sqerror * U[u_idx, i] * I[i_idx, j] * A[a_idx, k]
                        del_u[u_idx, i] += del_sqerror * G1[i, j, k] * I[i_idx, j] * A[a_idx, k]
                        del_i[i_idx, j] += del_sqerror * G1[i, j, k] * U[u_idx, i] * A[a_idx, k]
                        del_a[a_idx, k] += del_sqerror * G1[i, j, k] * U[u_idx, i] * I[i_idx, j]
        
        print("DONE UIF")
        uif_mse = error_square
        print("Training UFW")
        ufw_mse = 0
        # For the UFW portion
        for key in tqdm(mse_sample_2):
            pred_rating = get_value(G2, U, A, O, key)    
            del_sqerror = 2 * (pred_rating - sps_tensor_userwordf[key])
            error_square += (pred_rating - sps_tensor_userwordf[key])**2
            u_idx,a_idx,o_idx = key[0],key[1],key[2]
            for i in range(U_dim):
                for j in range(F_dim):
                    for k in range(W_dim):
                        del_g2[i, j, k] += del_sqerror * U[u_idx, i] * A[a_idx, j] * O[o_idx, k]
                        del_u[u_idx, i] += del_sqerror * G2[i, j, k] * A[a_idx, j] * O[o_idx, k]
                        del_a[a_idx, j] += del_sqerror * G2[i, j, k] * U[u_idx, i] * O[o_idx, k]
                        del_o[o_idx, k] += del_sqerror * G2[i, j, k] * U[u_idx, i] * A[a_idx, j]
            
        print("DONE UFW")
        ufw_mse = (error_square - uif_mse)
        
        print("Training IFW")
        ifw_mse = 0
        # For the IFW portion    
        for key in tqdm(mse_sample_3):
            pred_rating = get_value(G3, I, A, O, key)
            del_sqerror = 2 * (pred_rating - sps_tensor_itemwordf[key])
            error_square += (pred_rating - sps_tensor_itemwordf[key])**2
            i_idx,a_idx,o_idx = key[0],key[1],key[2]
            for i in range(I_dim):
                for j in range(F_dim):
                    for k in range(W_dim):
                        del_g3[i, j, k] += del_sqerror * I[i_idx, i] * A[a_idx, j] * O[o_idx, k]
                        del_i[i_idx, i] += del_sqerror * G3[i, j, k] * A[a_idx, j] * O[o_idx, k]
                        del_a[a_idx, j] += del_sqerror * G3[i, j, k] * I[i_idx, i] * O[o_idx, k]
                        del_o[o_idx, k] += del_sqerror * G3[i, j, k] * I[i_idx, i] * A[a_idx, j]
        
        print("DONE IFW")
        ifw_mse = (error_square - ufw_mse - uif_mse)
        print("---Done with reconstruction---")
        
        print("Training BPR")
        # For the BPR portion: Always we definitely have the item_i to be + and item_j to be -ve
        for key in tqdm(bpr_sample_ele):
            user,item_i = key[0],key[1]
            item_j = np.random.choice(neg_items[user],1)[0]
            pred_i = get_value(G1, U, I, A, (user,item_i,-1))
            pred_j = get_value(G1, U, I, A, (user,item_j,-1))
            
            pred = (pred_i - pred_j)
            score = (1.0 / (1.0 + np.exp(-pred)))
            
            del_bpr = lmd_BPR * score
            error_bpr += np.log(1 / (1 + np.exp(-pred)))
            for i in range(U_dim):
                for j in range(I_dim):
                    i_ij = I[item_i, j] - I[item_j, j]
                    for k in range(F_dim):
                        del_g1[i, j, k] -= del_bpr * U[user, i] * i_ij * A[F_num, k]
                        del_u[user, i] -= del_bpr * G1[i, j, k] * i_ij * A[F_num, k]
                        del_i[item_i, j] -= del_bpr * G1[i, j, k] * U[user, i] * A[F_num, k]
                        del_i[item_j, j] += del_bpr * G1[i, j, k] * U[user, i] * A[F_num, k]
                        del_a[F_num, k] -= del_bpr * G1[i, j, k] * U[user, i] * i_ij
        
        mse1_num = len(mse_sample_1) 
        mse2_num = len(mse_sample_2)
        mse3_num = len(mse_sample_3)
        bpr_num = len(bpr_sample_ele)
        
        total_num = mse1_num + mse2_num + mse3_num
        
        uifs.append((uif_mse / mse1_num))
        ufws.append((ufw_mse / mse2_num))
        ifws.append((ifw_mse / mse3_num))
        bpr_loss.append(-error_bpr / bpr_num)
        total_mse.append(error_square / total_num)
        
        print("UIF Error:",round(uifs[-1],6))
        print("UFW Error:",round(ufws[-1],6))
        print("IFW Error:",round(ifws[-1],6))
        print('Total Error:', round(total_mse[-1],6))
        print('BPR:', round(bpr_loss[-1],6))
        print("GRADIENTS:\n\n")
        print("G1: ",np.linalg.norm(del_g1))
        print("G2: ",np.linalg.norm(del_g2))
        print("G3: ",np.linalg.norm(del_g3))
        print("U: ",np.linalg.norm(del_u))
        print("I: ",np.linalg.norm(del_i))
        print("F: ",np.linalg.norm(del_a))
        print("W: ",np.linalg.norm(del_o))
        
        
        print("GRADIENT UPDATES DONE NOW:")
        for i in tqdm(range(U_dim)):
            for j in range(U_num):
                if del_u[j, i] != 0:
                    del_u_reg[j, i] += del_u[j, i] + ld_reg * U[j, i]
                sgrad_U[j, i] += eps + del_u_reg[j, i] * del_u_reg[j, i]
                U[j, i] -= (lr / np.sqrt(sgrad_U[j, i])) * del_u_reg[j, i]
                if U[j, i] < 0:
                    U[j, i] = 0

            for j in range(I_dim):
                for k in range(F_dim):
                    if del_g1[i, j, k] != 0:
                        del_g1_reg[i, j, k] += del_g1[i, j, k] + ld_reg * G1[i, j, k]
                    sgrad_G1[i, j, k] += eps + del_g1_reg[i, j, k] * del_g1_reg[i, j, k]
                    G1[i, j, k] -=  (lr / np.sqrt(sgrad_G1[i, j, k])) * del_g1_reg[i, j, k]
                    if G1[i, j, k] < 0:
                        G1[i, j, k] = 0

            for j in range(F_dim):
                for k in range(W_dim):
                    if del_g2[i, j, k] != 0:
                        del_g2_reg[i, j, k] += del_g2[i, j, k] + ld_reg * G2[i, j, k]
                    sgrad_G2[i, j, k] += eps + del_g2_reg[i, j, k] * del_g2_reg[i, j, k]
                    G2[i, j, k] -=  (lr / np.sqrt(sgrad_G2[i, j, k])) * del_g2_reg[i, j, k]
                    if G2[i, j, k] < 0:
                        G2[i, j, k] = 0

        for i in (range(I_dim)):
            for j in range(I_num):
                if del_i[j, i] != 0:
                    del_i_reg[j, i] += del_i[j, i] + ld_reg * I[j, i]
                sgrad_I[j, i] += eps + del_i_reg[j, i] * del_i_reg[j, i]
                I[j, i] -= (lr / np.sqrt(sgrad_I[j, i])) * del_i_reg[j, i]
                if I[j, i] < 0:
                    I[j, i] = 0

            for j in (range(F_dim)):
                for k in range(W_dim):
                    if del_g3[i, j, k] != 0:
                        del_g3_reg[i, j, k] += del_g3[i, j, k] + ld_reg * G3[i, j, k]
                    sgrad_G3[i, j, k] += eps + del_g3_reg[i, j, k] * del_g3_reg[i, j, k]
                    G3[i, j, k] -= (lr / np.sqrt(sgrad_G3[i, j, k])) * del_g3_reg[i, j, k]
                    if G3[i, j, k] < 0:
                        G3[i, j, k] = 0

        for i in (range(F_num + 1)):
            for j in range(F_dim):
                if del_a[i, j] != 0:
                    del_a_reg[i, j] += del_a[i, j] + ld_reg * A[i, j]
                sgrad_A[i, j] += eps + del_a_reg[i, j] * del_a_reg[i, j]
                A[i, j] -= (lr / np.sqrt(sgrad_A[i, j])) * del_a_reg[i, j]
                if A[i, j] < 0:
                    A[i, j] = 0

        for i in (range(W_num)):
            for j in range(W_dim):
                if del_o[i, j] != 0:
                    del_o_reg[i, j] += del_o[i, j] + ld_reg * O[i, j]
                sgrad_O[i, j] += eps + del_o_reg[i, j] * del_o_reg[i, j]
                O[i, j] -= (lr / np.sqrt(sgrad_O[i, j])) * del_o_reg[i, j]
                if O[i, j] < 0:
                    O[i, j] = 0

        print("WEIGHTS\n\n")
        print("G1: ",np.linalg.norm(G1))
        print("G2: ",np.linalg.norm(G2))
        print("G3: ",np.linalg.norm(G3))
        print("U: ",np.linalg.norm(U))
        print("I: ",np.linalg.norm(I))
        print("F: ",np.linalg.norm(A))
        print("W: ",np.linalg.norm(O))
        
        if epoch % print_every == 0 or epoch == 1 or epoch == num_iter:
            val = False
            save(G1,G2,G3,U,I,A,O,outfile)
            if epoch == num_iter:
                val = True #evaluate on all users at the end else do just for smaller users as validation
                nd,re,pr,f1 = test(test_data,G1, U, I, A,rec_k = rec_k,val = val)
                continue
            
            nd,re,pr,f1 = test(test_data,G1, U, I, A,rec_k = rec_k,val = val)
            ndcgs.append(nd)
            recalls.append(re)
            precisions.append(pr)
            f1s.append(f1)

    
    plot_metrics([uifs,ufws,ifws,total_mse], metric_name = 'Loss-reconstruction', dataset = str(dataset), multi = True,names = ['UIF','UFW',"IFW","Total"],model_name = 'MTER')  
    plot_metrics(bpr_loss, metric_name = 'Loss-recommendation', dataset = str(dataset),model_name = 'MTER')
    plot_metrics(ndcgs,metric_name = 'NDCG@'+str(rec_k), dataset = str(dataset),model_name='MTER')
    plot_metrics(precisions,metric_name = 'Precision@'+str(rec_k), dataset = str(dataset),model_name='MTER')
    plot_metrics(recalls,metric_name = 'Recall@'+str(rec_k),  dataset = str(dataset), model_name='MTER')
    plot_metrics(f1s,metric_name = 'F1@'+str(rec_k),  dataset = str(dataset),model_name='MTER')
    return G1, G2, G3, U, I, A, O
