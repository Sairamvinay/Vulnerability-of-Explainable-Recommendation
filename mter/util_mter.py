import numpy as np
from sklearn.metrics import ndcg_score
import matplotlib.pyplot as plt
import os
from tqdm import tqdm
import sys

def plot_metrics(metrics, metric_name = 'Loss',dataset = "Electronics",adv = False, adv_method = 'fgsm',eps = 0.5, multi = False,names = None,model_name = 'CER-BASE'):
    epochs = list(range(1 , 1 + len(metrics)))
    image_name = model_name+"-plots/" + dataset + "_" + metric_name
    if adv:
        image_name += '_ADV'+"_"+str(adv_method)+"_"+str(eps)
    dirname = os.path.dirname(os.path.abspath(image_name))
    os.makedirs(dirname, exist_ok=True)
    plt.figure(figsize = (12,8))
    plt.title(model_name + "-" + dataset + "-" + metric_name + ' vs Epochs')
    
    if multi:
        
        for name,metric in zip(names,metrics):
            epochs = list(range(1 , 1 + len(metric)))
            plt.plot(epochs, metric, label = name)
    else:
        plt.plot(epochs, metrics)
    
    
    plt.xlabel("Epochs")
    plt.ylabel(metric_name)
    if multi:
        plt.legend()
    
    plt.savefig(image_name + '.png')

    
def evaluate_user_perspective(user_perspective_data, u_i_expl_dict):
    pres = []
    recs = []
    f1s = []
    for u_i, gt_features in user_perspective_data.items():
        if u_i in u_i_expl_dict:
            TP = 0
            pre_features = u_i_expl_dict[u_i]
            # print('f: ground: ', gt_features, ' predicted: ',pre_features)
            for feature in pre_features:
                if feature in gt_features:
                    TP += 1
            pre = TP / max(len(pre_features),1)
            rec = TP / max(len(gt_features),1)
            if (pre + rec) != 0:
                f1 = (2 * pre * rec) / (pre + rec)
            else:
                f1 = 0
            pres.append(pre)
            recs.append(rec)
            f1s.append(f1)
    ave_pre = np.mean(pres)
    ave_rec = np.mean(recs)
    ave_f1 = np.mean(f1s)
    return ave_pre, ave_rec, ave_f1     
    
def faster_get_value(G,U,I,F,indices):
    
    dim1,dim2,dim3 = G.shape
    u_idx,i_idx,a_idx = indices[0],indices[1],indices[2]
    scores = np.zeros(len(i_idx))
    for i in tqdm(range(dim1)):
        for j in (range(dim2)):
            for k in (range(dim3)):
                Gs = np.repeat(G[i,j,k],len(i_idx))
                scores = scores + (Gs *  U[u_idx, i] * I[i_idx, j] * F[a_idx, k])
    
    return scores



def test(test_data,G1, U, I, A,rec_k = 50, val = False):
    
    Ks = [5,10,20,50,100]
    max_K = max(Ks)
    top_k = {}
    precisions = {5:[],10:[],20:[],50:[],100:[]}
    recalls = {5:[],10:[],20:[],50:[],100:[]}
    ndcgs= {5:[], 10:[], 20: [], 50: [], 100:[]}
    top_k_items = []
    u_inds = []
    i_inds = []
    a_inds = []
    gt_inds = []
    num_test_items = 0
    
    num_users = 500
    if val:
        num_users = len(test_data) 
    
    for row in (test_data[:num_users]):
        user = row[0]
        items,gt_labels = row[1],row[2]
        
        if user == 0:
            num_test_items = len(items)
        
        
        i_inds += items.ravel().tolist()
        u_inds += [user for _ in items]
        a_inds += [-1 for _ in items]
        gt_inds += gt_labels.ravel().tolist()
    
    
    print("Doing calculation now..")
    scores = faster_get_value(G1,U,I,A,(u_inds,i_inds,a_inds))
    scores = np.array(scores)
    print("DONE..")
    
    
    for index,row in enumerate(test_data[:num_users]):
        user = row[0]
        items = row[1]
        scores_user = scores[index * num_test_items: (index + 1) * num_test_items]
        labels_user = gt_inds[index * num_test_items: (index + 1) * num_test_items]
        triple = [(item,ground,score) for item,ground,score in list(zip(items,labels_user,scores_user))]
        triple.sort(key = lambda x: x[2],reverse= True)
        top_k[user] = triple[:max_K]
        
        
        for top in Ks:
            curr_triple = triple[:top]
            items_recommended,gt_k,score_k = list(zip(*curr_triple))
            items_relevant = [item for i,(item,score,label) in enumerate(zip(items_recommended, score_k,gt_k))  if label == 1]

            common = set(items) & set(items_relevant)
            common_size = len(common)
            recalls[top].append(common_size / len(items))
            precisions[top].append(common_size / min([top, len(items)]))
            ndcg = ndcg_score([gt_k], [score_k], k=top)
            ndcgs[top].append(ndcg)

    returns = ()
    
    if val:
        print("For all users")
    else:
        print("For ",num_users," users")
    
    for top in Ks:
        recall = np.mean(recalls[top])
        precision = np.mean(precisions[top])
        
        if precision + recall != 0:
            f1 = 2 * recall * precision / (precision + recall)
        
        else:
            f1 = 0.0
        
        precision = round(precision,6)
        recall = round(recall,6)
        f1 = round(f1,6)
        ndcg = round(np.mean(ndcgs[top]),6)
        if top == rec_k:
            returns = (ndcg, recall, precision, f1)
        print("\t\t", 'NDCG@',top,":",ndcg,end = '\t\t')
        print("Precision@",top,":",precision,'Recall@',top,":", recall," F1@",top,":",f1)
    
    return returns